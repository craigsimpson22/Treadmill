name: Build Interval Runner APK (phone-only, one file)

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      - name: Install SDK packages
        run: |
          sdkmanager --install "platform-tools" "platforms;android-35" "build-tools;35.0.0"

      - name: Create Android project files (UI+icon updates)
        run: |
          set -e
          mkdir -p IntervalRunner/app/src/main/java/com/craig/intervalrunner
          mkdir -p IntervalRunner/app/src/main/res/values
          mkdir -p IntervalRunner/app/src/main/res/mipmap-anydpi-v26
          mkdir -p IntervalRunner/app/src/main/res/drawable

          cat > IntervalRunner/settings.gradle.kts << 'EOF'
          pluginManagement { repositories { gradlePluginPortal(); google(); mavenCentral() } }
          dependencyResolutionManagement {
              repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
              repositories { google(); mavenCentral() }
          }
          rootProject.name = "IntervalRunner"
          include(":app")
          EOF

          cat > IntervalRunner/build.gradle.kts << 'EOF'
          plugins {
              id("com.android.application") version "8.5.0" apply false
              kotlin("android") version "1.9.24" apply false
          }
          EOF

          cat > IntervalRunner/gradle.properties << 'EOF'
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          android.useAndroidX=true
          kotlin.code.style=official
          android.nonTransitiveRClass=true
          EOF

          cat > IntervalRunner/app/build.gradle.kts << 'EOF'
          plugins {
              id("com.android.application")
              kotlin("android")
          }

          android {
              namespace = "com.craig.intervalrunner"
              compileSdk = 35

              defaultConfig {
                  applicationId = "com.craig.intervalrunner"
                  minSdk = 26
                  targetSdk = 35
                  versionCode = 1
                  versionName = "1.0.0"
                  testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
              }

              // Java/Kotlin 17 to match CI
              compileOptions {
                  sourceCompatibility = JavaVersion.VERSION_17
                  targetCompatibility = JavaVersion.VERSION_17
              }
              kotlinOptions { jvmTarget = "17" }

              buildTypes {
                  release {
                      isMinifyEnabled = false
                      proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
                  }
                  debug { isMinifyEnabled = false }
              }

              buildFeatures { compose = true }
              composeOptions { kotlinCompilerExtensionVersion = "1.5.14" }

              packaging { resources { excludes += "/META-INF/{AL2.0,LGPL2.1}" } }
          }

          dependencies {
              val composeBom = platform("androidx.compose:compose-bom:2024.06.00")
              implementation(composeBom)
              androidTestImplementation(composeBom)

              implementation("com.google.android.material:material:1.12.0")
              implementation("androidx.core:core-ktx:1.13.1")
              implementation("androidx.activity:activity-compose:1.9.0")
              implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.8.2")
              implementation("androidx.lifecycle:lifecycle-runtime-compose:2.8.2")
              implementation("androidx.compose.ui:ui")
              implementation("androidx.compose.material3:material3")
              implementation("androidx.compose.ui:ui-tooling-preview")
              debugImplementation("androidx.compose.ui:ui-tooling")

              testImplementation("junit:junit:4.13.2")
              androidTestImplementation("androidx.test.ext:junit:1.2.1")
              androidTestImplementation("androidx.test.espresso:espresso-core:3.6.1")
              androidTestImplementation("androidx.compose.ui:ui-test-junit4")
          }
          EOF

          cat > IntervalRunner/app/proguard-rules.pro << 'EOF'
          # No special rules required
          EOF

          # Manifest uses crisp adaptive icon
          cat > IntervalRunner/app/src/main/AndroidManifest.xml << 'EOF'
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">
              <uses-permission android:name="android.permission.VIBRATE" />
              <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />

              <application
                  android:allowBackup="true"
                  android:icon="@mipmap/ic_launcher"
                  android:label="@string/app_name"
                  android:theme="@style/Theme.IntervalRunner">
                  <activity
                      android:name=".MainActivity"
                      android:exported="true"
                      android:screenOrientation="portrait">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN"/>
                          <category android:name="android.intent.category.LAUNCHER"/>
                      </intent-filter>
                  </activity>
              </application>
          </manifest>
          EOF

          # Theme
          cat > IntervalRunner/app/src/main/res/values/themes.xml << 'EOF'
          <resources>
              <style name="Theme.IntervalRunner" parent="Theme.Material3.DayNight.NoActionBar">
                  <item name="android:statusBarColor">@android:color/transparent</item>
                  <item name="android:navigationBarColor">@android:color/black</item>
              </style>
          </resources>
          EOF

          # Strings
          cat > IntervalRunner/app/src/main/res/values/strings.xml << 'EOF'
          <resources>
              <string name="app_name">Interval Runner</string>
          </resources>
          EOF

          # Adaptive icon (fitness runner silhouette; sharp vector, not pixelated)
          cat > IntervalRunner/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml << 'EOF'
          <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
              <background android:drawable="@color/ic_launcher_background"/>
              <foreground android:drawable="@drawable/ic_launcher_foreground"/>
          </adaptive-icon>
          EOF

          cat > IntervalRunner/app/src/main/res/values/ic_launcher_background.xml << 'EOF'
          <resources>
              <color name="ic_launcher_background">#121212</color>
          </resources>
          EOF

          # Simple vector runner: head (circle stroke) + limbs (stroked lines) for crisp, scalable icon
          cat > IntervalRunner/app/src/main/res/drawable/ic_launcher_foreground.xml << 'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="108dp" android:height="108dp"
              android:viewportWidth="108" android:viewportHeight="108">
              <!-- Head -->
              <path
                  android:fillColor="#00000000"
                  android:strokeColor="#FFFFFF"
                  android:strokeWidth="6"
                  android:strokeLineCap="round"
                  android:pathData="M54,26 m -8,0 a8,8 0 1,0 16,0 a8,8 0 1,0 -16,0"/>
              <!-- Torso / forward arm -->
              <path android:fillColor="#00000000" android:strokeColor="#FFFFFF" android:strokeWidth="8"
                  android:strokeLineCap="round"
                  android:pathData="M54,34 L64,48"/>
              <!-- Back arm -->
              <path android:fillColor="#00000000" android:strokeColor="#FFFFFF" android:strokeWidth="8"
                  android:strokeLineCap="round"
                  android:pathData="M54,38 L44,48"/>
              <!-- Front leg -->
              <path android:fillColor="#00000000" android:strokeColor="#FFFFFF" android:strokeWidth="8"
                  android:strokeLineCap="round"
                  android:pathData="M64,48 L76,64"/>
              <!-- Back leg -->
              <path android:fillColor="#00000000" android:strokeColor="#FFFFFF" android:strokeWidth="8"
                  android:strokeLineCap="round"
                  android:pathData="M54,50 L44,66"/>
          </vector>
          EOF

          # MainActivity with layout fixes, auto-scaling timer, status chip, and saved inputs
          cat > IntervalRunner/app/src/main/java/com/craig/intervalrunner/MainActivity.kt << 'EOF'
          package com.craig.intervalrunner

          import android.content.Context
          import android.media.AudioManager
          import android.media.ToneGenerator
          import android.os.Bundle
          import android.os.VibrationEffect
          import android.os.Vibrator
          import android.speech.tts.TextToSpeech
          import android.view.WindowManager
          import androidx.activity.ComponentActivity
          import androidx.activity.compose.setContent
          import androidx.compose.foundation.background
          import androidx.compose.foundation.layout.*
          import androidx.compose.foundation.layout.statusBarsPadding
          import androidx.compose.foundation.layout.navigationBarsPadding
          import androidx.compose.foundation.lazy.LazyRow
          import androidx.compose.foundation.lazy.itemsIndexed
          import androidx.compose.material3.*
          import androidx.compose.runtime.*
          import androidx.compose.runtime.saveable.rememberSaveable
          import androidx.compose.ui.Alignment
          import androidx.compose.ui.Modifier
          import androidx.compose.ui.graphics.Color
          import androidx.compose.ui.text.font.FontWeight
          import androidx.compose.ui.text.style.TextAlign
          import androidx.compose.ui.unit.Dp
          import androidx.compose.ui.unit.dp
          import androidx.compose.ui.unit.sp
          import kotlinx.coroutines.delay
          import java.util.Locale
          import kotlin.math.max
          import kotlin.math.min

          data class Segment(val kind: Kind, val lengthSec: Int) {
              enum class Kind { FAST, SLOW }
          }

          private const val PREFS = "interval_prefs"
          private const val K_FAST = "fastMin"
          private const val K_SLOW = "slowMin"
          private const val K_CYCLES = "cycles"
          private const val K_PREP = "prepSec"

          class MainActivity : ComponentActivity() {
              private var tts: TextToSpeech? = null
              private var tone: ToneGenerator? = null

              override fun onCreate(savedInstanceState: Bundle?) {
                  super.onCreate(savedInstanceState)
                  window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)

                  val prefs = getSharedPreferences(PREFS, Context.MODE_PRIVATE)
                  val startFast = prefs.getInt(K_FAST, 3)
                  val startSlow = prefs.getInt(K_SLOW, 3)
                  val startCycles = prefs.getInt(K_CYCLES, 5)
                  val startPrep = prefs.getInt(K_PREP, 30) // default 30s

                  tts = TextToSpeech(this) { if (it == TextToSpeech.SUCCESS) { tts?.language = Locale.UK; tts?.setSpeechRate(1.0f) } }
                  tone = ToneGenerator(AudioManager.STREAM_MUSIC, 80)

                  setContent {
                      MaterialTheme(colorScheme = darkColorScheme()) {
                          IntervalApp(
                              initialFastMin = startFast,
                              initialSlowMin = startSlow,
                              initialCycles = startCycles,
                              initialPrepSec = startPrep,
                              onSave = { f, s, c, p ->
                                  prefs.edit().putInt(K_FAST, f).putInt(K_SLOW, s).putInt(K_CYCLES, c).putInt(K_PREP, p).apply()
                              },
                              speak = { speak(it) },
                              beep = { beep(it) },
                              vibrate = { vibrate(it) }
                          )
                      }
                  }
              }

              private fun speak(text: String) { try { tts?.speak(text, TextToSpeech.QUEUE_FLUSH, null, "utt") } catch (_: Throwable) {} }
              private fun beep(fast: Boolean) {
                  try {
                      val toneType = if (fast) ToneGenerator.TONE_SUP_RADIO_ACK else ToneGenerator.TONE_PROP_BEEP
                      tone?.startTone(toneType, 250)
                  } catch (_: Throwable) {}
              }
              private fun vibrate(pattern: LongArray) {
                  val vib = getSystemService(VIBRATOR_SERVICE) as Vibrator
                  try {
                      if (android.os.Build.VERSION.SDK_INT >= 26) vib.vibrate(VibrationEffect.createWaveform(pattern, -1))
                      else @Suppress("DEPRECATION") vib.vibrate(pattern, -1)
                  } catch (_: Throwable) {}
              }
              override fun onDestroy() { super.onDestroy(); tts?.stop(); tts?.shutdown(); tone?.release() }
          }

          @Composable
          fun IntervalApp(
              initialFastMin: Int,
              initialSlowMin: Int,
              initialCycles: Int,
              initialPrepSec: Int,
              onSave: (Int, Int, Int, Int) -> Unit,
              speak: (String) -> Unit,
              beep: (Boolean) -> Unit,
              vibrate: (LongArray) -> Unit
          ) {
              var fastMin by rememberSaveable { mutableStateOf(initialFastMin) }
              var slowMin by rememberSaveable { mutableStateOf(initialSlowMin) }
              var cycles by rememberSaveable { mutableStateOf(initialCycles) }
              var prepSec by rememberSaveable { mutableStateOf(initialPrepSec) }

              LaunchedEffect(fastMin, slowMin, cycles, prepSec) { onSave(fastMin, slowMin, cycles, prepSec) }

              val segments = remember(fastMin, slowMin, cycles) {
                  buildList {
                      repeat(cycles) {
                          add(Segment(Segment.Kind.FAST, fastMin * 60))
                          add(Segment(Segment.Kind.SLOW, slowMin * 60))
                      }
                  }
              }
              val totalSec = segments.sumOf { it.lengthSec }
              var currentIndex by remember { mutableStateOf(-1) } // -1 = prep
              var secLeft by remember { mutableStateOf(prepSec) }
              var running by remember { mutableStateOf(false) }
              var finished by remember { mutableStateOf(false) }

              LaunchedEffect(currentIndex) {
                  if (currentIndex >= 0 && currentIndex < segments.size) {
                      val seg = segments[currentIndex]
                      beep(seg.kind == Segment.Kind.FAST)
                      vibrate(longArrayOf(100, 50, 100))
                      speak(if (seg.kind == Segment.Kind.FAST) "Fast pace" else "Slow pace")
                  }
              }

              LaunchedEffect(running, secLeft, currentIndex, segments) {
                  while (running) {
                      delay(1000)
                      secLeft -= 1
                      if (currentIndex == -1 && secLeft <= 0) {
                          currentIndex = 0; secLeft = segments.getOrNull(0)?.lengthSec ?: 0
                      } else if (currentIndex >= 0 && secLeft <= 0) {
                          val next = currentIndex + 1
                          if (next < segments.size) { currentIndex = next; secLeft = segments[next].lengthSec }
                          else { running = false; finished = true; beep(true); delay(220); beep(true); delay(220); beep(false); vibrate(longArrayOf(200,100,200,100,200)); speak("Workout complete") }
                      }
                  }
              }

              LaunchedEffect(fastMin, slowMin, cycles, prepSec) {
                  if (!running) { currentIndex = -1; secLeft = prepSec; finished = false }
              }

              val elapsedSec = when {
                  currentIndex < 0 -> 0
                  currentIndex >= segments.size -> totalSec
                  else -> segments.take(currentIndex).sumOf { it.lengthSec } + ((segments[currentIndex].lengthSec) - secLeft)
              }
              val pct = if (totalSec == 0) 0 else min(100, max(0, (elapsedSec * 100) / totalSec))
              val currentKind = when {
                  currentIndex == -1 -> "PREP"
                  currentIndex >= segments.size -> "DONE"
                  else -> segments[currentIndex].kind.name
              }

              Surface(
                  modifier = Modifier
                      .fillMaxSize()
                      .background(Color(0xFF0B0B0E))
                      .padding(horizontal = 16.dp)
                      .statusBarsPadding()        // top safe area
                      .navigationBarsPadding()    // bottom safe area
                      .padding(bottom = 8.dp)
              ) {
                  Column(
                      horizontalAlignment = Alignment.CenterHorizontally,
                      verticalArrangement = Arrangement.Top,
                      modifier = Modifier.fillMaxSize()
                  ) {
                      // Title kept but not oversized to avoid clipping
                      Text("Interval Runner", style = MaterialTheme.typography.headlineLarge.copy(fontWeight = FontWeight.ExtraBold))
                      Spacer(Modifier.height(8.dp))

                      // Inputs
                      Row(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth()) {
                          NumberField("Fast (min)", fastMin, { fastMin = it.coerceIn(1, 60) }, modifier = Modifier.weight(1f))
                          NumberField("Slow (min)", slowMin, { slowMin = it.coerceIn(1, 60) }, modifier = Modifier.weight(1f))
                          NumberField("Cycles", cycles, { cycles = it.coerceIn(1, 30) }, modifier = Modifier.weight(1f))
                          NumberField("Prep (sec)", prepSec, { prepSec = it.coerceIn(0, 180) }, modifier = Modifier.weight(1f))
                      }

                      Spacer(Modifier.height(10.dp))

                      // Big status/timer card (fills most space)
                      Card(modifier = Modifier.weight(1f).fillMaxWidth()) {
                          Box(modifier = Modifier.fillMaxSize().padding(16.dp)) {
                              // Status chip in top-right (the little badge)
                              val badgeColor = when (currentKind) {
                                  "FAST" -> Color(0xFF34D399); "SLOW" -> Color(0xFF60A5FA); "PREP" -> Color(0xFFF59E0B); else -> Color(0xFFA78BFA)
                              }
                              AssistChip(
                                  onClick = {},
                                  label = { Text(currentKind) },
                                  colors = AssistChipDefaults.assistChipColors(labelColor = Color.Black, containerColor = badgeColor),
                                  modifier = Modifier.align(Alignment.TopEnd)
                              )

                              // Centered timer + short status label
                              ResponsiveTimer(
                                  seconds = secLeft,
                                  label = when (currentKind) { "FAST" -> "Fast pace"; "SLOW" -> "Slow pace"; "PREP" -> "Get readyâ€¦"; else -> "All done!" },
                                  modifier = Modifier.align(Alignment.Center)
                              )

                              // Progress at bottom
                              LinearProgressIndicator(
                                  progress = pct / 100f,
                                  modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth().height(12.dp)
                              )
                          }
                      }

                      Spacer(Modifier.height(10.dp))

                      // Buttons
                      Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                          if (!running) {
                              Button(onClick = { beep(true); running = true }) { Text(if (currentIndex == -1) "Start" else if (finished) "Restart" else "Resume") }
                          } else {
                              OutlinedButton(onClick = { running = false }) { Text("Pause") }
                          }
                          OutlinedButton(onClick = { running = false; currentIndex = -1; secLeft = prepSec; finished = false }) { Text("Reset") }
                      }

                      Spacer(Modifier.height(10.dp))

                      // Segments list (kept above nav bar)
                      LazyRow(
                          horizontalArrangement = Arrangement.spacedBy(8.dp),
                          modifier = Modifier.fillMaxWidth(),
                          contentPadding = PaddingValues(bottom = 8.dp)
                      ) {
                          itemsIndexed(segments) { idx, seg ->
                              val bg = if (seg.kind == Segment.Kind.FAST) Color(0x2234D399) else Color(0x2260A5FA)
                              Card(colors = CardDefaults.cardColors(containerColor = bg)) {
                                  Column(Modifier.padding(12.dp), horizontalAlignment = Alignment.CenterHorizontally) {
                                      Text(seg.kind.name, fontWeight = FontWeight.SemiBold)
                                      Text(mmss(seg.lengthSec), color = Color(0xFF9EA3AF))
                                      Text("#${idx + 1}", color = Color(0xFF6B7280))
                                  }
                              }
                          }
                      }
                  }
              }
          }

          @Composable
          private fun ResponsiveTimer(seconds: Int, label: String, modifier: Modifier = Modifier) {
              BoxWithConstraints(modifier = modifier) {
                  val minSide = min(maxWidth, maxHeight)
                  // Big as possible but stay reasonable: ~1/3 of min side per digit pair
                  val timeSize = (minSide.value * 0.28f).sp.coerceAtLeast(42.sp)
                  val labelSize = (minSide.value * 0.08f).sp.coerceAtLeast(14.sp)

                  Column(horizontalAlignment = Alignment.CenterHorizontally) {
                      Text(
                          text = mmss(seconds),
                          fontSize = timeSize,
                          fontWeight = FontWeight.ExtraBold,
                          textAlign = TextAlign.Center
                      )
                      Spacer(Modifier.height(6.dp))
                      Text(label, color = Color(0xFFB0B3B8), fontSize = labelSize, textAlign = TextAlign.Center)
                  }
              }
          }

          @Composable
          private fun NumberField(
              label: String,
              value: Int,
              onChange: (Int) -> Unit,
              modifier: Modifier = Modifier
          ) {
              var text by rememberSaveable(value) { mutableStateOf(value.toString()) }
              OutlinedTextField(
                  value = text,
                  onValueChange = {
                      text = it.filter { ch -> ch.isDigit() }.take(3)
                      text.toIntOrNull()?.let(onChange)
                  },
                  label = { Text(label) },
                  singleLine = true,
                  modifier = modifier.fillMaxWidth()
              )
          }

          private fun mmss(s: Int): String {
              val m = (s / 60).coerceAtLeast(0); val ss = (s % 60).coerceAtLeast(0)
              return "%02d:%02d".format(m, ss)
          }
          EOF

      - name: Ensure Gradle wrapper and build
        working-directory: IntervalRunner
        run: |
          if [ ! -f ./gradlew ]; then
            gradle wrapper --gradle-version 8.7
          fi
          chmod +x gradlew
          ./gradlew --no-daemon assembleDebug

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: IntervalRunner-debug-apk
          path: IntervalRunner/app/build/outputs/apk/debug/app-debug.apk
